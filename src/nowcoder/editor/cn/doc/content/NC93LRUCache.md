<div>  设计LRU(最近最少使用)缓存结构，该结构在构造时确定大小，假设大小为 capacity ，操作次数是 n ，并有如下功能:<br> 1. Solution(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br> 2. get(key)：如果关键字 key 存在于缓存中，则返回key对应的value值，否则返回 -1 。<br> 3. set(key, value)：将记录(key, value)插入该结构，如果关键字 key 已经存在，则变更其数据值 value，如果不存在，则向缓存中插入该组 key-value ，如果key-value的数量超过capacity，弹出最久未使用的key-value<br> </div> <div> </div> <div>  <br> </div> <div>  提示:<br> 1.某个key的set或get操作一旦发生，则认为这个key的记录成了最常使用的，然后都会刷新缓存。<br> 2.当缓存的大小超过capacity时，移除最不经常使用的记录。<br> 3.返回的value都以字符串形式表达，如果是set，则会输出&quot;null&quot;来表示(不需要用户返回，系统会自动输出)，方便观察<br> 4.函数set和get必须以O(1)的方式运行<br> 5.为了方便区分缓存里key与value，下面说明的缓存里key用&quot;&quot;号包裹 </div> <div>  数据范围: </div> <div>  <img src="https://www.nowcoder.com/equation?tex=1%5Cleq%20capacity%3C%3D10%5E5"><br> <span> </span><img src="https://www.nowcoder.com/equation?tex=0%5Cleq%20key%2Cval%20%5Cleq%202%5Ctimes%2010%5E9%20%5C"><br> <img src="https://www.nowcoder.com/equation?tex=1%5Cleq%20n%5Cleq%2010%5E5"><br> <br> </div><div><br></div><div><div>Related Topics</div><div><li>链表</li><li>哈希</li><li>模拟</li></div></div><br>示例:<br>输入:["set","set","get","set","get","set","get","get","get"],[[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]],2<br>输出:["null","null","1","null","-1","null","-1","3","4"]<br>